<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Limpeza Oce√¢nica</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #0066cc, #003366);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #004080;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 100, 200, 0.5);
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #0080ff 0%, #0066cc 30%, #004080 70%, #002040 100%);
        }
        
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="gameUI">
            <div>Lixo Coletado: <span id="trashCount">0</span></div>
            <div>Vidas: <span id="lives">1</span></div>
        </div>
        
        <div id="instructions">
            WASD/Setas: Mover | E/Espa√ßo: Coletar lixo | R: Reiniciar
        </div>
        
        <div id="gameOver">
            <h2 id="gameOverTitle">Game Over!</h2>
            <p id="gameOverMessage"></p>
            <p>Pressione R para reiniciar</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverDiv = document.getElementById('gameOver');
        
        // Estado do jogo
        let gameState = {
            running: true,
            trashCollected: 0,
            lives: 1
        };
        
        // Submarino
        let submarine = {
            x: 100,
            y: canvas.height / 2,
            width: 60,
            height: 30,
            vx: 0, // Velocidade X
            vy: 0, // Velocidade Y
            speed: 0.3, // Acelera√ß√£o
            friction: 0.95, // Atrito
            angle: 0, // √Çngulo de rota√ß√£o
            collectRange: 80
        };
        
        // Vari√°veis para o movimento do cen√°rio
        let backgroundX = 0;
        const backgroundScrollSpeed = 0.5; // Velocidade de rolagem do cen√°rio
        
        // Arrays para objetos do jogo
        let fish = [];
        let trash = [];
        let particles = [];
        let bubbles = [];
        
        // Controles
        let keys = {};
        
        // Inicializar jogo
        function initGame() {
            submarine.x = 100;
            submarine.y = canvas.height / 2;
            submarine.vx = 0; // Resetar velocidade
            submarine.vy = 0; // Resetar velocidade
            submarine.angle = 0; // Resetar √¢ngulo
            gameState.running = true;
            gameState.trashCollected = 0;
            gameState.lives = 1;
            
            backgroundX = 0; // Resetar a posi√ß√£o do cen√°rio
            
            fish = [];
            trash = [];
            particles = [];
            bubbles = [];
            
            gameOverDiv.style.display = 'none';
            
            // Criar peixes iniciais (o n√∫mero foi reduzido de 4 para 2)
            for (let i = 0; i < 2; i++) {
                createFish();
            }
            
            // Criar lixo inicial
            for (let i = 0; i < 12; i++) {
                createTrash();
            }
            
            // Criar bolhas iniciais
            for (let i = 0; i < 15; i++) {
                createBubble();
            }
            
            updateUI();
        }
        
        // Criar peixe
        function createFish() {
            const fishTypes = ['üêü', 'üê†', 'üê°', 'ü¶à', 'üêô', 'ü¶ë', 'üê¢'];
            fish.push({
                x: canvas.width + Math.random() * 200, // Spawn off-screen to the right
                y: 50 + Math.random() * (canvas.height - 100),
                width: 40,
                height: 40,
                speed: 1 + Math.random() * 2,
                type: fishTypes[Math.floor(Math.random() * fishTypes.length)],
                direction: Math.random() > 0.5 ? 1 : -1,
                amplitude: 20 + Math.random() * 30,
                frequency: 0.02 + Math.random() * 0.03,
                phase: Math.random() * Math.PI * 2
            });
        }
        
        // Criar lixo
        function createTrash() {
            const trashTypes = ['üóëÔ∏è', 'ü•§', 'üçæ', 'üõçÔ∏è', 'üì¶', '‚öôÔ∏è', 'üîã'];
            trash.push({
                x: canvas.width + Math.random() * 300, // Spawn off-screen to the right
                y: 50 + Math.random() * (canvas.height - 100),
                width: 30,
                height: 30,
                speed: 0.5 + Math.random() * 1,
                type: trashTypes[Math.floor(Math.random() * trashTypes.length)],
                collected: false,
                bobOffset: Math.random() * Math.PI * 2
            });
        }
        
        // Criar bolha
        function createBubble() {
            bubbles.push({
                x: Math.random() * canvas.width,
                y: canvas.height + Math.random() * 100,
                size: 5 + Math.random() * 15,
                speed: 0.5 + Math.random() * 1.5,
                opacity: 0.3 + Math.random() * 0.4
            });
        }
        
        // Criar part√≠cula de explos√£o
        function createExplosion(x, y) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 30,
                    maxLife: 30,
                    color: `hsl(${Math.random() * 60 + 10}, 100%, 50%)`
                });
            }
        }
        
        // Atualizar jogo
        function update() {
            if (!gameState.running) return;
            
            // Mover submarino
            if (keys['w'] || keys['arrowup']) submarine.vy -= submarine.speed;
            if (keys['s'] || keys['arrowdown']) submarine.vy += submarine.speed;
            if (keys['a'] || keys['arrowleft']) submarine.vx -= submarine.speed;
            if (keys['d'] || keys['arrowright']) submarine.vx += submarine.speed;

            // Aplicar atrito
            submarine.vx *= submarine.friction;
            submarine.vy *= submarine.friction;

            // Atualizar posi√ß√£o
            submarine.x += submarine.vx;
            submarine.y += submarine.vy;

            // Calcular √¢ngulo baseado na velocidade
            if (Math.abs(submarine.vx) > 0.1 || Math.abs(submarine.vy) > 0.1) {
                submarine.angle = Math.atan2(submarine.vy, submarine.vx);
            }
            
            // Verificar limites da tela
            if (submarine.y <= 0 || submarine.y >= canvas.height - submarine.height) {
                gameOver("Impacto com os limites da miss√£o!");
                return;
            }
            
            // Manter submarino dentro dos limites horizontais
            submarine.x = Math.max(0, Math.min(canvas.width - submarine.width, submarine.x));
            
            // Atualizar posi√ß√£o do cen√°rio para rolagem
            backgroundX += backgroundScrollSpeed;
            if (backgroundX >= canvas.width) {
                backgroundX = 0; // Reiniciar quando o cen√°rio rolar uma tela inteira
            }

            // Atualizar peixes
            for (let i = fish.length - 1; i >= 0; i--) {
                let f = fish[i];
                f.x -= f.speed + backgroundScrollSpeed; // Mover peixes para a esquerda com o cen√°rio
                f.phase += f.frequency;
                f.y += Math.sin(f.phase) * f.amplitude * 0.1;
                
                // Verificar colis√£o com submarino
                if (checkCollision(submarine, f)) {
                    gameOver("Voc√™ atingiu um animal marinho!");
                    return;
                }
                
                // Remover peixes que sa√≠ram da tela e criar novos
                if (f.x < -f.width) {
                    fish.splice(i, 1);
                    createFish();
                }
            }
            
            // Atualizar lixo
            for (let i = trash.length - 1; i >= 0; i--) {
                let t = trash[i];
                if (!t.collected) {
                    t.x -= t.speed + backgroundScrollSpeed; // Mover lixo para a esquerda com o cen√°rio
                    t.bobOffset += 0.05;
                    t.y += Math.sin(t.bobOffset) * 0.5;
                    
                    // Verificar se est√° dentro do range de coleta
                    let distance = Math.sqrt(
                        Math.pow(submarine.x + submarine.width/2 - (t.x + t.width/2), 2) +
                        Math.pow(submarine.y + submarine.height/2 - (t.y + t.height/2), 2)
                    );
                    
                    if (distance <= submarine.collectRange && (keys['e'] || keys[' '])) {
                        t.collected = true;
                        gameState.trashCollected++;
                        updateUI();
                        
                        // Criar efeito de coleta
                        for (let j = 0; j < 5; j++) {
                            particles.push({
                                x: t.x + t.width/2,
                                y: t.y + t.height/2,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 20,
                                maxLife: 20,
                                color: '#00ff00'
                            });
                        }
                    }
                }
                
                // Remover lixo coletado ou que saiu da tela
                if (t.collected || t.x < -t.width) {
                    trash.splice(i, 1);
                    if (!t.collected) {
                        createTrash();
                    } else {
                        // Criar novo lixo ap√≥s coletar
                        setTimeout(createTrash, 2000 + Math.random() * 3000);
                    }
                }
            }
            
            // Atualizar bolhas
            for (let i = bubbles.length - 1; i >= 0; i--) {
                let b = bubbles[i];
                b.y -= b.speed;
                
                if (b.y < -b.size) {
                    bubbles.splice(i, 1);
                    createBubble();
                }
            }
            
            // Atualizar part√≠culas
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Adicionar novos peixes ocasionalmente
            // A frequ√™ncia foi reduzida de 0.01 para 0.005 para diminuir a quantidade de peixes
            if (Math.random() < 0.005) {
                createFish();
            }
        }
        
        // Verificar colis√£o
        function checkCollision(obj1, obj2) {
            const center1X = obj1.x + obj1.width / 2;
            const center1Y = obj1.y + obj1.height / 2;
            const center2X = obj2.x + obj2.width / 2; 
            const center2Y = obj2.y + obj2.height / 2;

            const dx = center1X - center2X;
            const dy = center1Y - center2Y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const combinedRadius = (Math.max(obj1.width, obj1.height) / 2) + (Math.max(obj2.width, obj2.height) / 2);
            return distance < combinedRadius;
        }
        
        // Renderizar jogo
        function render() {
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenhar fundo oce√¢nico
            drawOceanBackground();
            
            // Desenhar bolhas
            bubbles.forEach(bubble => {
                ctx.globalAlpha = bubble.opacity;
                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
            
            // Desenhar range de coleta do submarino
            if (gameState.running) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(
                    submarine.x + submarine.width/2,
                    submarine.y + submarine.height/2,
                    submarine.collectRange,
                    0, Math.PI * 2
                );
                ctx.stroke();
            }
            
            // Desenhar submarino
            if (gameState.running) {
                drawSubmarine();
            }
            
            // Desenhar peixes
            fish.forEach(f => {
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(f.type, f.x + f.width/2, f.y + f.height/2 + 10);
            });
            
            // Desenhar lixo
            trash.forEach(t => {
                if (!t.collected) {
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(t.type, t.x + t.width/2, t.y + t.height/2 + 10);
                    
                    // Destacar lixo dentro do range
                    let distance = Math.sqrt(
                        Math.pow(submarine.x + submarine.width/2 - (t.x + t.width/2), 2) +
                        Math.pow(submarine.y + submarine.height/2 - (t.y + t.height/2), 2)
                    );
                    
                    if (distance <= submarine.collectRange) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(t.x - 5, t.y - 5, t.width + 10, t.height + 10);
                    }
                }
            });
            
            // Desenhar part√≠culas
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            });
        }
        
        // Desenhar fundo oce√¢nico
        function drawOceanBackground() {
            // Plantas aqu√°ticas e corais s√£o desenhados duas vezes para criar um loop cont√≠nuo
            const drawElements = (offsetX) => {
                // Plantas aqu√°ticas
                for (let i = 0; i < 10; i++) {
                    let x = i * 80 + (Math.sin(Date.now() * 0.001 + i) * 10) + offsetX;
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(x, canvas.height - 60, 3, 60);
                    ctx.fillRect(x + 10, canvas.height - 80, 3, 80);
                }
                
                // Corais
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i < 5; i++) {
                    let x = i * 160 + 50 + offsetX;
                    ctx.fillText('ü™∏', x, canvas.height - 20);
                }
            };

            // Desenha o cen√°rio principal
            drawElements(-backgroundX);
            // Desenha uma segunda c√≥pia do cen√°rio para criar o loop
            drawElements(-backgroundX + canvas.width);

            // Se o cen√°rio principal saiu da tela, reinicia a posi√ß√£o
            if (-backgroundX <= -canvas.width) {
                backgroundX = 0;
            }
        }
        
        // Desenhar submarino (AGORA COM ROTA√á√ÉO!)
        function drawSubmarine() {
            ctx.save(); // Salva o estado atual do canvas
            // Move o ponto de origem para o centro do submarino para rota√ß√£o
            ctx.translate(submarine.x + submarine.width / 2, submarine.y + submarine.height / 2);
            ctx.rotate(submarine.angle); // Rotaciona o canvas

            // Desenhe o submarino em torno de (0,0) (que agora √© o centro do submarino)
            ctx.fillStyle = '#FFD700'; // Cor dourada
            
            // Corpo principal (agora centrado em 0,0)
            ctx.fillRect(-submarine.width / 2, -submarine.height / 2 + 8, submarine.width - 10, submarine.height - 16);
            
            // Frente pontiaguda
            ctx.beginPath();
            ctx.moveTo(submarine.width / 2 - 10, -submarine.height / 2 + 8);
            ctx.lineTo(submarine.width / 2, 0); // Centro do submarino
            ctx.lineTo(submarine.width / 2 - 10, submarine.height / 2 - 8);
            ctx.fill();
            
            // Torre
            ctx.fillRect(-submarine.width / 2 + 15, -submarine.height / 2, 20, 15);
            
            // Perisc√≥pio
            ctx.fillStyle = '#B8860B';
            ctx.fillRect(-submarine.width / 2 + 20, -submarine.height / 2 - 5, 2, 10);
            
            // Janelas
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(-submarine.width / 2 + 8, -submarine.height / 2 + 12, 8, 6);
            ctx.fillRect(-submarine.width / 2 + 25, -submarine.height / 2 + 12, 8, 6);
            
            // H√©lice
            ctx.fillStyle = '#696969';
            let propellerAngle = Date.now() * 0.02;
            ctx.save();
            ctx.translate(-submarine.width / 2, 0); // Move para a parte traseira do submarino
            ctx.rotate(propellerAngle);
            ctx.fillRect(-8, -2, 16, 4);
            ctx.fillRect(-2, -8, 4, 16);
            ctx.restore();

            ctx.restore(); // Restaura o estado original do canvas
        }
        
        // Game Over
        function gameOver(message) {
            gameState.running = false;
            document.getElementById('gameOverMessage').textContent = message;
            gameOverDiv.style.display = 'block';
        }
        
        // Atualizar UI
        function updateUI() {
            document.getElementById('trashCount').textContent = gameState.trashCollected;
            document.getElementById('lives').textContent = gameState.lives;
        }
        
        // Loop principal do jogo
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners
        document.addEventListener('keydown', function(e) {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true;
            
            // Bug escondido: Ctrl + Backspace
            if ((e.ctrlKey || e.metaKey) && e.key === 'Backspace') {
                createExplosion(submarine.x + submarine.width/2, submarine.y + submarine.height/2);
                gameOver("üí• Submarino explodiu! ( Parece que voc√™ n√£o conseguiu limpar o lixo )");
            }
            
            // Reiniciar jogo
            if (e.key.toLowerCase() === 'r') {
                initGame();
            }
            
            e.preventDefault();
        });
        
        document.addEventListener('keyup', function(e) {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false;
        });
        
        // Inicializar e come√ßar o jogo
        initGame();
        gameLoop();
    </script>
</body>
</html>
